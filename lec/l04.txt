L4: Wrap-up reasoning about crashes

=== Solution to exercise 4

Discuss proof Recover_rok

Discuss proof Recover_ok
  rexec?
  exec_recover
  exec
  idempotence

Read_rok: combine Read_ok + Recover_ok

=== Logging

How to use a disk when the computer might crash?
  Consider a single disk
  Consider banking application

Example: transfer (a, b, 10)
  requires updating two blocks

Naive plan: overwrite
  write block a
  write block b
  what if we crash in the middle?
  can we undo?
  can we complete?

Better plan: no updates in place
  shadow copy [btrfs, like functional data structure]
  logging

Logging
  picture of disk with log and data
  
  start
    append a to log
    append b to log
  commit
    write commit record
    install a and b
  end
    optionally truncate log
    
  recovery
    no commit record: do nothing
    commit record: install

  is recovery idempotent?

  class infrastructure can specify and proof a log
    see FSCQ paper

maybe show FSCQ source code
  log, rep invariants, specs
  crash at higher levels is always LOG.rep

=== Relaxing assumptions

Atomic sector write
  model: crash condition randomizes

No bit-flips 
  model: concurrent corruption

Synchronous disks
  Disk buffer internally to disk
    must be explicitly flushed
    concurrent
  Buffering writes in computer's memory
    to get absorption
  model: valuset

Checksums
  model: non-termination

No concurrent procedure

non-deterministic specs
  seems important to hide irrelevant details

No confidentiality guarantees
  how to get confidentiality guarantees without deterministic specs?
