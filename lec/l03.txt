L3: Recovery

=== Solution of exercise 3

src/ReplicatedDisk/ReplicatedDiskImpl.v
  work through implementations of Read, DiskSize, DiskSizeInit, init_at, Init
    what if we didn't initialize?
    of course our abstraction wouldn't hold, but so what?
    could someone observe an incorrect behavior at the spec level?
  walk through the proof of Read_ok
  discuss Write_ok and write_read_ok specs
  walk through the proof of DiskSize_ok: same as Read_ok, basically
  discuss init_at_ok: induction because of fixpoint loop
  walk through the proof of DiskSizeInit_ok
    if we do two [step]s in a row, we get an [exists] subgoal
    automation couldn't figure out how to instantiate the evars for precondition
    reason: it depends on [r], the result of the first [DiskSize] call
    [destruct r] first, now [step] can keep going through

Write solution

Write_ok proof

=== Recovery

Crashes & recovery

  What happens when a computer crashes?
    Stops
    Reboot
    Runs recovery
    Start serving request again

  Why do we need recovery?
    Consider replicated disk without recovery
    Consider write
      if computer crashes between two disk updates, the disks are out of sync
    Now consider two back-to-back reads of out-of-sync block
      first read returns value of first disk
      first disk fails
      second read returns different value
      --> Not allowed by spec
      --> Recovery provides a way to repair disks so that we can serve requests
        that obey spec

   Computer may crash during recovery
     Recovery function must be idempotent
     That is, it must be ok to run it over and over
 
How do we model this?
  Draw state diagram
    Each code state can start running recovery
    Fork off regular code path with recovery steps
    If recovery ends, it ends in some state
      that state is either the old spec state
      or corresponds to the new spec state
    Crashes during recovery
      Every state can invoke recovery again!

   Result: infinite many code paths
     Observation: exploit idempotence of recovery procedure
       Its recovery condition must imply its precondition
       Collapses many code paths

Example: replicated disk
   What is the recovery condition?
     interesting case: crash during write
     what are the possible code states?
   What must the recovery procedure do?
     sync up the disk disks
   Can the recovery procedure be idempotent?
     what code states can it be in if computer crashes?
     Same states as write
     So, yes, must be possible to be idempotent

Look at some code
  read_ok, write_ok's recovery conditions
  implementation of recovery
    fixup, recovery_at
  proofs of recovery
    - draw on board (DiskStatus, RecStatus)
    - diagram of when you transition status
    - proof of fixup_ok, and recover_at_ok
      also look at recovery condition
    - proof of Recover_rok
    - proof of Recover_ok
      idempotence
    - statementent of Write_rok.
  
  
  




