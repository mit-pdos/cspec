L3: Recovery

=== Solution of exercise 3

approach to proofs: Hoare logic
  pre- and post-conditions for procedures
  general shape of what [proc_spec] says:

          pre                   post
           |                      |
           V                      V
    code state --[procedure]--> state'

  top-level [proc_spec] statement has a precondition that maps the
    starting code state to the starting spec state, and postcondition
    that maps the final code state to the correspoding final spec state.

  precondition takes additional argument as input, which can appear in
    postcondition.  useful for saying "if exists some abstract state in
    the precondition, then..."

automating [proc_spec] proofs
  what if we need a proof for a [proc_spec] about "a ; b"?

     pre                             post
      |                               |
      V                               V
    state0 --[a]--> state1 --[b]--> state2

  find a [proc_spec] for [a] and line up our precondition with that spec's
  then reduce to proving a [proc_spec] for b, with [a]'s post as the new pre
  keep doing this repeatedly

  two requirements:
    - can find a [proc_spec] for the [a] program
    - can line up our current state precondition with [a]'s [proc_spec] pre

src/ReplicatedDisk/ReplicatedDiskImpl.v
  work through implementations of Read, DiskSize, DiskSizeInit, init_at, Init
    what if we didn't initialize?
    of course our abstraction wouldn't hold, but so what?
    could someone observe an incorrect behavior at the spec level?

  walk through the proof of Read_ok
    pull up src/ReplicatedDisk/TwoDiskProgSpec.v to see the [proc_spec] of Read

  Write implementation and proof of Write_ok

  discuss init_at_ok: induction because of fixpoint loop

  walk through the proof of DiskSizeInit_ok
    if we do two [step]s in a row, we get an [exists] subgoal
    automation couldn't figure out how to instantiate the evars for precondition
    reason: it depends on [r], the result of the first [DiskSize] call
    [destruct r] first, now [step] can keep going through

=== Recovery

Crashes & recovery

  What happens when a computer crashes?
    Stops
    Reboots
    Runs recovery
    Start serving request again

  Why do we need recovery?
    Consider replicated disk without recovery
    Consider write
      if computer crashes between two disk updates, the disks are out of sync
    Now consider two back-to-back reads of out-of-sync block
      first read returns value of first disk
      first disk fails
      second read returns different value
      --> Not allowed by spec
      --> Recovery provides a way to repair disks so that we can serve requests
        that obey spec

   Computer may crash during recovery
     Recovery function must be idempotent
     That is, it must be ok to run it over and over
 
How do we model this?
  Draw state diagram
    Each code state can start running recovery
    Fork off regular code path with recovery steps
    If recovery ends, it ends in some state
      that state is either the old spec state
      or corresponds to the new spec state
    Crashes during recovery
      Every state can invoke recovery again!

   Result: infinite many code paths
     Observation: exploit idempotence of recovery procedure
       Its recovery condition must imply its precondition
       Collapses many code paths

Example: replicated disk
   What is the recovery condition?
     interesting case: crash during write
     what are the possible recovery states?
   What must the recovery procedure do?
     sync up the disk disks
   Can the recovery procedure be idempotent?
     what crash states can it be in if computer crashes?
     Same states as write
     So, yes, recovery is idempotent

Look at some code
  read_ok, write_ok's recovery conditions
  implementation of recovery
    fixup, recovery_at
  proofs of recovery
    - draw on board (DiskStatus, RecStatus)
    - diagram of when you transition status
    - proof of fixup_ok, and recover_at_ok
      also look at recovery condition
    - proof of Recover_rok
    - proof of Recover_ok
      idempotence
    - statementent of Write_rok.
  
  
  




