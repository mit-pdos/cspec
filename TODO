Things to clean up:

- RemappedDisk: make sure that we can replace the abstraction relation with an abstraction function
  as defined in the [init] part of the proof at the bottom of RemappedDiskImpl.v.

- students need to install haskell-stack; document this better and tell them how to do it

- minimal NBD client that reads/writes sectors, to test/demo remap-nbd with broken write

- see notes below from Perry Metzger about how to run stack on a Mac

- use coqdoc more

- comments in the code should point to where various pieces are defined (e.g., Interface, API, etc)

- change [recover] name conflict: both Hoare.recover and customary recovery procedure name

- horizontal composition: compose NBD and TwoDisk/BadSectorDisk

- security with horizontal composition: make [proc_spec] a two-execution property

- something extractable for lab3 (atomic pair)

===

Things we've figured out:

- Why [proc_spec] is useful: avoid having to reason about execution of functions twice
  (once for normal execution -- postcondition, and once for crashes -- recovery condition).
  That ends up with a quadratic number of subgoals.

  Also [proc_spec] helps avoid the many cases generated by [prog_spec_symbolic_execute]
  in RemappedDiskImpl.v, as an example.

- why step-style definitions of semantics are useful: good for cases when there
  are background steps, and it's not obvious that a particular [proc_spec] correctly
  takes into account all of the possible background step interleavings.

- Why should we go with [proc_spec] instead of Butler-style refinement?

  + Proof engineering problem.  Need to separately reason about crash-free
    executions vs. recovery.  This means reasoning about a non-atomic interface
    which Butler-style refinement does not support.  Could in principle reason
    about normal+recovery, but that makes the proofs complicated.

  + Crashes are not special.  Could model them in the same way as Butler-style
    refinement does, by setting a "recovering" bit and halting execution on a
    crash.  Recovery will pick up the "recovering" state and clean it up.

  + To make the invariant precise enough, you'd have to include the PC of every
    thread in the global invariant, which makes the invariant unwieldy.  The
    [proc_spec] approach separates out reasoning about thread-private vs global
    state.

  + How to use refinement to reason about implementations of code inside of a
    transaction system?  E.g., write-ahead-log provides a general transaction
    facility, and then we want to run "A; B; C".  B cannot be atomic: it will
    roll back to before A or after C, neither of which B knows about..  Can we
    prove a refinement about B (e.g., the directory code in a FS) in isolation
    of A and C?

===

Notes for when we explain the labs to students:

- explain haskell extraction more, how the pieces fit together

- remapped disk lab:
  + explain what's with None vs Some x: in-bounds vs out-of-bounds.
  + what happens to the bad sector?  it's (Some x) for a garbage value x.

===

Things we probably don't need to clean up:

- it would be nice if [proc_spec_symbolic_execute] labeled the subgoals it
  created based on the if statements that led to it.  an easy way to do this
  would be to introduce a "Label" opcode to the language.

  empirically, though, we didn't run into confusion about which branch is where
  during DSSS.

- explain how symbolic execution works

- explain correspondence of tactics to commutative diagram:
  symbolic execution goes across
  prove_final_state goes up to the spec layer

- better story for what's going on with the [world] business

===

So, on a mac
 
(1) you must have Xcode installed from the app store to get the haskell bits working. (If you don’t have XCode already installed, you’ll need Sierra (10.12) to get it.)

(2) Download ghc 8.0.2 “core” from https://www.haskell.org/platform/mac.html

(3) Run “stack config set system-ghc --global true” then “stack setup”. Then you can run make on the repository successfully.
￼
If you have already installed GHC via homebrew, step (3) is sufficient to run make.

===

to keep track of the kinds of symbolic execution cases we need to handle:

  [if] statements where conditions are [sumor]s, like [if (a == b) then foo else bar]

  [if] statements where conditions are [bool]s, like [if (a =? b) then foo else bar]

  [match] statements that do some kind of case analysis

  [if] statements at the top level of the program, like
    [if foo then Ret 1 else Ret 2]

  [if] statements inside a program, like
    Ret (if foo then 1 else 2)
